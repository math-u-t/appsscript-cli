import * as fs from 'fs-extra';
import * as path from 'path';
import { glob } from 'glob';
import { BuildResult, GScriptConfig } from '../types';
import { CompatibilityChecker } from '../checker';

export class Builder {
  private config: GScriptConfig;

  constructor(config: GScriptConfig) {
    this.config = config;
  }

  async build(srcDir: string, outputPath: string, skipCheck: boolean = false): Promise<BuildResult> {
    const issues = skipCheck ? [] : await this.checkCompatibility(srcDir);

    const errors = issues.filter(i => i.severity === 'error');
    if (errors.length > 0 && !skipCheck) {
      return {
        success: false,
        outputFile: outputPath,
        issues,
        warnings: issues.filter(i => i.severity === 'warning').length,
        errors: errors.length
      };
    }

    // Find all source files
    const files = await glob('**/*.{ts,js}', {
      cwd: srcDir,
      ignore: this.config.excludePatterns || []
    });

    // Sort files by dependency order
    const sortedFiles = await this.sortByDependencies(srcDir, files);

    // Concatenate files
    let output = this.generateHeader();

    for (const file of sortedFiles) {
      const filePath = path.join(srcDir, file);
      const content = await fs.readFile(filePath, 'utf-8');
      const processed = this.processFile(content, file);
      output += `\n// ===== ${file} =====\n\n`;
      output += processed;
      output += '\n';
    }

    // Ensure output directory exists
    await fs.ensureDir(path.dirname(outputPath));

    // Write output
    await fs.writeFile(outputPath, output, 'utf-8');

    return {
      success: true,
      outputFile: outputPath,
      issues,
      warnings: issues.filter(i => i.severity === 'warning').length,
      errors: 0
    };
  }

  private async checkCompatibility(srcDir: string) {
    const checker = new CompatibilityChecker(this.config);
    return checker.checkProject(srcDir);
  }

  private generateHeader(): string {
    return `/**
 * Auto-generated by gscript
 * Generated: ${new Date().toISOString()}
 * Runtime: ${this.config.runtime}
 *
 * DO NOT EDIT THIS FILE DIRECTLY
 * Edit source files in src/ and run 'gscript build'
 */

`;
  }

  private processFile(content: string, filename: string): string {
    // Remove import/export statements
    let processed = content;

    // Remove import statements
    processed = processed.replace(/^import\s+.*?;?\s*$/gm, '');
    processed = processed.replace(/^import\s+.*?from\s+['"].*?['"];?\s*$/gm, '');

    // Remove export keywords but keep the declarations
    processed = processed.replace(/^export\s+default\s+/gm, '');
    processed = processed.replace(/^export\s+/gm, '');
    processed = processed.replace(/^export\s*\{[^}]*\};?\s*$/gm, '');

    // Remove TypeScript type-only imports
    processed = processed.replace(/^import\s+type\s+.*?;?\s*$/gm, '');

    // Clean up excessive blank lines
    processed = processed.replace(/\n{3,}/g, '\n\n');

    return processed.trim();
  }

  private async sortByDependencies(srcDir: string, files: string[]): Promise<string[]> {
    // Simple dependency sorting based on file references
    // In a more sophisticated implementation, this would parse imports
    // For now, we use a heuristic: main.ts goes last

    const sorted = [...files];

    sorted.sort((a, b) => {
      // Main file should be last
      if (a.includes('main.')) return 1;
      if (b.includes('main.')) return -1;

      // Utility files should be first
      if (a.includes('util') || a.includes('helper')) return -1;
      if (b.includes('util') || b.includes('helper')) return 1;

      // Otherwise alphabetical
      return a.localeCompare(b);
    });

    return sorted;
  }

  async createAppsScriptManifest(outputDir: string): Promise<void> {
    const manifest = {
      timeZone: this.config.timeZone || 'America/New_York',
      dependencies: this.config.dependencies || {},
      exceptionLogging: 'STACKDRIVER',
      runtimeVersion: this.config.runtime,
      oauthScopes: this.config.oauthScopes || [],
      webapp: this.config.webApp
    };

    const manifestPath = path.join(outputDir, 'appsscript.json');
    await fs.writeJson(manifestPath, manifest, { spaces: 2 });
  }
}
